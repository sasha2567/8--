%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Интерпретатор (машина вывода) для ЭС продукционного типа 
% Метод вывода: обратный вывод 
% Вариант 1: интерпретатор обрабатывает правила, в  которых 
% предпосылки задаются в виде условий (не более 2-х), соединенных оператором "и". 
% ------------------------------------------------------------------------------- 
% Примеры правил см. в загружаемой тестовой  базе знаний - nb.pl 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
:-dynamic 
сообщено/2. 
% объявление операторов 
определить_операторы:- 
       op(920, xfy, и), 
       op(950, xfx, то), 
       op(960, fx, если), 
       op(970, xfx, '::'). 
:-определить_операторы. 
 
%============обратный вывод======================================================= 
% реализуется предикатом найти(H,Стек,Д), где H - проверяемая гипотеза (цель), 
% Стек - стек из имен доказываемых гипотез и правил (используется при ответе на  
% вопросы "почему"), Д - дерево вывода целевого утверждения (используется при отве- 
% те на вопросы "как"). Предикат получает на вход Н и Стек=[H] и в процессе обрат- 
% ного вывода строит дерево вывода Д. 
%--------------------------------------------------------------------------------- 
 
% случай1:если цель Н была подтверждена пользователем, 
% то дерево вывода Д=сообщено(Н). 
найти(H,Стек,сообщено(H)):-сообщено(H,да). 
% если цель - это признак, то спроси его значение 
найти(H,Стек,сообщено(H)):-запрашиваемая(H), 
                           not(сообщено(H,_)),спроси(H,Стек). 
 
% случай2:если цель Н подтверждается фактом, уже известным системе, 
% то дерево вывода Д=Факт :: H 
найти(H,Стек,Факт :: H):-Факт :: H. 
 
% случай3: если цель Н соответствует следствию одного из  
% правил -> Правило :: если H1 то H 
% и если Д1 дерево вывода для подцели Н1, 
% то Д= Правило :: если Д1 то H и номер правила добавить в Стек 
найти(H,Стек,Правило :: если Д1 то H):-  
                    Правило :: если H1 то H, 
                    найти(H1,[Правило | Стек],Д1). 
 
% случай4: если доказывается конъюнкция гипотез H=H1 и Н2,  
% то дерево вывода Д=Д1 и Д2, где Д1,Д2 - деревья вывода гипотез H1 и Н2 
найти(H1 и H2,Стек,Д1 и Д2):- 
    найти(H1,Стек,Д1),найти(H2,Стек,Д2). 
 
% проверка: является ли гипотеза признаком, значение которого можно спросить 
запрашиваемая(H):-Факт :: признак(H). 
 
%=========вывод вопросов и обработка ответов "да, нет, почему" ================== 
% вывод вопроса и ввод ответа 
спроси(H,Стек):-write(H),write('?'),nl, 
                read(O),ответ(H,O,Стек). 
 
% обработка ответов: да, нет. 
ответ(H,да,Стек):-assert(сообщено(H,да)),!. 
ответ(H,нет,Стек):-assert(сообщено(H,нет)),!,fail.  
 
% обработка ответов - "почему" 
% случай1: стек целей пустой   55
ответ(H,почему,[]):-!,write(' Вы задаете слишком много вопросов'),nl,  
                    спроси(H,[]). 
%случай2: в стеке только первая введенная цель, т.е. доказываемая гипотеза 
ответ(H,почему,[H1]):-!,write('моя гипотеза: '), 
                      write(H1),nl,спроси(H,[]). 
% случай3: если в стеке несколько элементов, то вывод заключения (т.е. подцели) 
% и номера текущего применяемого правила 
ответ(H,почему,[Правило | Стек]):-!, 
    Правило :: если H1 то H2, 
    write('пытаюсь доказать '), 
    write(H2),nl, 
    write('с помощью правила: '), 
    write(Правило),nl, 
    спроси(H,Стек). 
 
% неправильный ответ: повторяем вопрос 
ответ(H,_,Стек):-write(' правильный ответ: да, нет, почему'),nl, 
                 спроси(H,Стек). 
 
%==============обработка ответов на вопросы "как?"===============================   
% предикат как(H,Д)- выполняет поиск подцели Н в построенном  
% с помощью предиката "найти" дереве вывода Д и отображает соответствующий 
% фрагмент дерева вывода, объясняя, как было получено доказательство Н. 
% Дерево вывода Д представляет собой последовательность вложенных правил, напри- 
% мер: 
% правило2::если (правило4::если сообщено(плита(холодная))и  
%                                сообщено(лампа(не_светится)) 
%                           то тока(нет)) 
%           то выключатель(не_включен) 
% -------------------------------------------------------------------------------- 
 
% поиск целевого утверждения Н в дереве   
как(H,Дерево):-как1(H,Дерево),!. 
 
% вывод сообщения, если Н не найдено в дереве   
как(H,_):-write(H),tab(2),write('не доказано'),nl. 
 
% случай1: если Н сообщено пользователем, 
% то вывести "Н было введено" 
как1(H,_):-сообщено(H,_),!,                           
           write(H),write('было введено'),nl. 
 
% случай2: если дерево вывода Д представлено фактом, подтверждающим Н 
как1(H,Факт :: H):-!,                                       
         write(H), write( 'является фактом'), write(Факт),nl. 
 
% случай3: если дерево вывода Д - правило в заключение, которого есть Н, 
% то отобразить это правило 
как1(H,Правило :: если _ то H):-!,            
         write(H),write('было доказано с помощью'),nl, 
         Правило :: если H1 то H, 
         отобрази_правило(Правило :: если H1 то H). 
 
% случай4: если в дереве Д нет правила с заключением Н, 
%то поиск Н надо выполнять в дереве предпосылок, т.е. в Дерево 
как1(H,Правило :: если Дерево то _):-как(H,Дерево).         
 
% случай5: если предпосылки образуют конъюнкцию, 
% то выполнить поиск в поддеревьях Дерево1 и Дерево2 
как1(H,Правило :: если Дерево1 и Дерево2 то _):-как(H,Дерево1),как(H,Дерево2). 
 
%вывод правила на экран 
отобрази_правило(Правило :: если H1 то H):-    
         write(Правило), write( ':'),nl, 
         write('если '), write(H1), nl, 
         write('то '), write(H),nl. 

инициализация:-retractall(сообщено(_,_)). 
start:- 
      /* Загрузка базы знаний из файла */ 
  reconsult('rules1111111111111111111111111111.pl'), 
  info,                     %отображение информации о базе знаний* 
  go_exp_sys. 
 
go_exp_sys:-  инициализация, 
              Факт :: гипотеза(H), 
              найти(H,[H],Дерево),  
              write('решение:'),write(H),nl, 
              объясни(Дерево), 
              возврат. 
 
 
%объяснение вывода утверждения 
объясни(Дерево):-write( 'объяснить ? [цель/нет]:'), nl,read(H),           
                 (H\=нет,!,как(H,Дерево),объясни(Дерево));!. 
 
%поиск следующих решений 
возврат:-nl,write('Искать ещё решение [да/нет]?: '),nl, read(нет). 